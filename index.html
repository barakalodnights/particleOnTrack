<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Track Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        #canvas {
            border: 3px solid white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: linear-gradient(145deg, #2c3e50, #34495e);
            cursor: crosshair;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            max-width: 600px;
            opacity: 0.9;
        }

        .status {
            margin-top: 10px;
            font-weight: bold;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¢ Particle Track Simulator</h1>
    
    <div class="controls">
        <button id="clearBtn">Clear Track</button>
        <button id="simulateBtn" disabled>Start Simulation</button>
        <button id="resetBtn" disabled>Reset Particle</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="instructions">
        <p>Draw a continuous path from the <strong>red start point</strong> (top-left) to the <strong>green end point</strong> (bottom-right).</p>
        <p>Then click "Start Simulation" to watch the particle roll down your track!</p>
        <p><strong>Vector Legend:</strong> <span style="color: #00b8ff;">Blue = Tangential Acceleration</span> | <span style="color: #ff4757;">Red = Normal Acceleration</span></p>
        <p><em>Vector length shows acceleration magnitude - Path automatically smoothed to reduce noise!</em></p>
        <div class="status" id="status">Ready to draw!</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const simulateBtn = document.getElementById('simulateBtn');
        const resetBtn = document.getElementById('resetBtn');
        const status = document.getElementById('status');

        let isDrawing = false;
        let path = [];
        let particle = null;
        let animationId = null;
        let isSimulating = false;

        // Fixed start and end points
        const startPoint = { x: 50, y: 50 };
        const endPoint = { x: canvas.width - 50, y: canvas.height - 50 };

        // Utility functions
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function isNearPoint(pos, point, threshold = 20) {
            const dx = pos.x - point.x;
            const dy = pos.y - point.y;
            return Math.sqrt(dx * dx + dy * dy) < threshold;
        }

        function smoothPath(rawPath, windowSize = 5) {
            if (rawPath.length < 3) return rawPath;
            
            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < rawPath.length; i++) {
                let sumX = 0, sumY = 0, count = 0;
                
                // Average points within the window
                for (let j = Math.max(0, i - halfWindow); j <= Math.min(rawPath.length - 1, i + halfWindow); j++) {
                    sumX += rawPath[j].x;
                    sumY += rawPath[j].y;
                    count++;
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }

        function reducePathPoints(path, minDistance = 3) {
            if (path.length < 2) return path;
            
            const reduced = [path[0]]; // Always keep first point
            
            for (let i = 1; i < path.length - 1; i++) {
                const lastPoint = reduced[reduced.length - 1];
                const currentPoint = path[i];
                const distance = Math.sqrt(
                    (currentPoint.x - lastPoint.x) ** 2 + 
                    (currentPoint.y - lastPoint.y) ** 2
                );
                
                // Only add point if it's far enough from the last added point
                if (distance >= minDistance) {
                    reduced.push(currentPoint);
                }
            }
            
            reduced.push(path[path.length - 1]); // Always keep last point
            return reduced;
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.ax = 0; // acceleration components
                this.ay = 0;
                this.radius = 8;
                this.pathIndex = 0;
                this.gravity = 0.3;
                this.friction = 0.98;
                this.bounceDecay = 0.7;
                
                // Smoothing for acceleration vectors
                this.accelHistory = [];
                this.maxHistoryLength = 5;
                this.smoothedTangentialAccel = 0;
                this.smoothedNormalAccel = 0;
            }

            update() {
                if (path.length < 2) return;

                // Store previous velocity for acceleration calculation
                const prevVx = this.vx;
                const prevVy = this.vy;

                // Find the closest point on the path
                let closestDist = Infinity;
                let closestIndex = 0;
                let closestPoint = null;

                for (let i = Math.max(0, this.pathIndex - 5); i < Math.min(path.length - 1, this.pathIndex + 10); i++) {
                    const p1 = path[i];
                    const p2 = path[i + 1];
                    
                    // Get closest point on this line segment
                    const closest = this.getClosestPointOnSegment(this.x, this.y, p1.x, p1.y, p2.x, p2.y);
                    const dist = Math.sqrt((this.x - closest.x) ** 2 + (this.y - closest.y) ** 2);
                    
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestIndex = i;
                        closestPoint = closest;
                    }
                }

                this.pathIndex = closestIndex;

                // Apply gravity
                this.vy += this.gravity;

                // If particle is close to the track, constrain it
                if (closestDist < this.radius * 2 && closestPoint) {
                    // Get track direction
                    const p1 = path[closestIndex];
                    const p2 = path[Math.min(closestIndex + 1, path.length - 1)];
                    const trackDx = p2.x - p1.x;
                    const trackDy = p2.y - p1.y;
                    const trackLength = Math.sqrt(trackDx * trackDx + trackDy * trackDy);
                    
                    if (trackLength > 0) {
                        const trackNormX = trackDx / trackLength;
                        const trackNormY = trackDy / trackLength;
                        
                        // Project velocity onto track direction
                        const velDot = this.vx * trackNormX + this.vy * trackNormY;
                        this.vx = velDot * trackNormX * this.friction;
                        this.vy = velDot * trackNormY * this.friction;
                        
                        // Keep particle on track
                        this.x = closestPoint.x;
                        this.y = closestPoint.y;
                    }
                } else {
                    // Free fall with air resistance
                    this.vx *= 0.995;
                    this.vy *= 0.995;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Calculate acceleration (change in velocity)
                this.ax = this.vx - prevVx;
                this.ay = this.vy - prevVy;

                // Update smoothed acceleration vectors
                this.updateSmoothedAcceleration();

                // Bounce off walls
                if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                    this.vx *= -this.bounceDecay;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                if (this.y + this.radius > canvas.height) {
                    this.vy *= -this.bounceDecay;
                    this.y = canvas.height - this.radius;
                    this.vx *= this.friction;
                }
            }

            updateSmoothedAcceleration() {
                // Get current tangent and normal vectors
                const vectors = this.getTangentAndNormal();
                
                // Calculate current tangential and normal accelerations
                const currentTangentialAccel = this.ax * vectors.tangent.x + this.ay * vectors.tangent.y;
                const currentNormalAccel = this.ax * vectors.normal.x + this.ay * vectors.normal.y;
                
                // Add to history
                this.accelHistory.push({
                    tangential: currentTangentialAccel,
                    normal: currentNormalAccel
                });
                
                // Keep history within limit
                if (this.accelHistory.length > this.maxHistoryLength) {
                    this.accelHistory.shift();
                }
                
                // Calculate smoothed values using exponential moving average
                const alpha = 0.05; // Smoothing factor (0 = no smoothing, 1 = no history)
                
                if (this.accelHistory.length === 1) {
                    // First frame
                    this.smoothedTangentialAccel = currentTangentialAccel;
                    this.smoothedNormalAccel = currentNormalAccel;
                } else {
                    // Exponential moving average
                    this.smoothedTangentialAccel = alpha * currentTangentialAccel + (1 - alpha) * this.smoothedTangentialAccel;
                    this.smoothedNormalAccel = alpha * currentNormalAccel + (1 - alpha) * this.smoothedNormalAccel;
                }
            }

            getClosestPointOnSegment(px, py, x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = dx * dx + dy * dy;
                
                if (length === 0) return { x: x1, y: y1 };
                
                let t = ((px - x1) * dx + (py - y1) * dy) / length;
                t = Math.max(0, Math.min(1, t));
                
                return {
                    x: x1 + t * dx,
                    y: y1 + t * dy
                };
            }

            getTangentAndNormal() {
                if (path.length < 2) return { tangent: { x: 0, y: 0 }, normal: { x: 0, y: 0 } };

                // Find current segment on path
                let p1, p2;
                if (this.pathIndex < path.length - 1) {
                    p1 = path[this.pathIndex];
                    p2 = path[this.pathIndex + 1];
                } else {
                    p1 = path[path.length - 2];
                    p2 = path[path.length - 1];
                }

                // Calculate tangent vector (direction of track)
                let tangentX = p2.x - p1.x;
                let tangentY = p2.y - p1.y;
                const tangentLength = Math.sqrt(tangentX * tangentX + tangentY * tangentY);
                
                if (tangentLength > 0) {
                    tangentX /= tangentLength;
                    tangentY /= tangentLength;
                }

                // Calculate normal vector (perpendicular to tangent, pointing toward center of curvature)
                // For better curvature calculation, look at surrounding points
                let normalX = 0, normalY = 0;
                
                if (this.pathIndex > 0 && this.pathIndex < path.length - 1) {
                    const prevPoint = path[this.pathIndex - 1];
                    const nextPoint = path[this.pathIndex + 1];
                    const currentPoint = path[this.pathIndex];
                    
                    // Calculate vectors from current point to prev and next
                    const toPrev = { 
                        x: prevPoint.x - currentPoint.x, 
                        y: prevPoint.y - currentPoint.y 
                    };
                    const toNext = { 
                        x: nextPoint.x - currentPoint.x, 
                        y: nextPoint.y - currentPoint.y 
                    };
                    
                    // Normalize these vectors
                    const toPrevLen = Math.sqrt(toPrev.x * toPrev.x + toPrev.y * toPrev.y);
                    const toNextLen = Math.sqrt(toNext.x * toNext.x + toNext.y * toNext.y);
                    
                    if (toPrevLen > 0) {
                        toPrev.x /= toPrevLen;
                        toPrev.y /= toPrevLen;
                    }
                    if (toNextLen > 0) {
                        toNext.x /= toNextLen;
                        toNext.y /= toNextLen;
                    }
                    
                    // The normal points toward the center of curvature
                    // This is the average of the two unit vectors, normalized
                    normalX = (toPrev.x + toNext.x);
                    normalY = (toPrev.y + toNext.y);
                    
                    const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);
                    if (normalLength > 0) {
                        normalX /= normalLength;
                        normalY /= normalLength;
                    } else {
                        // If points are collinear, normal is perpendicular to tangent
                        normalX = -tangentY;
                        normalY = tangentX;
                    }
                } else {
                    // At endpoints, normal is perpendicular to tangent
                    normalX = -tangentY;
                    normalY = tangentX;
                }

                return {
                    tangent: { x: tangentX, y: tangentY },
                    normal: { x: normalX, y: normalY }
                };
            }

            draw() {
                // Get tangent and normal vectors
                const vectors = this.getTangentAndNormal();
                
                // Use smoothed acceleration values
                const tangentialAccel = this.smoothedTangentialAccel;
                const normalAccel = this.smoothedNormalAccel;
                
                // Scale factor for visualization (make accelerations visible)
                const accelScale = 300; // Amplification factor for acceleration vectors
                
                // Calculate vector lengths based on acceleration magnitudes
                const tangentLength = Math.abs(tangentialAccel) * accelScale;
                const normalLength = Math.abs(normalAccel) * accelScale;
                
                // Draw tangent vector (tangential acceleration) - Blue
                if (tangentLength > 1) { // Only draw if acceleration is significant
                    // Direction: positive tangential accel = forward, negative = backward
                    const tangentDir = tangentialAccel >= 0 ? 1 : -1;
                    const tangentEndX = this.x + vectors.tangent.x * tangentLength * tangentDir;
                    const tangentEndY = this.y + vectors.tangent.y * tangentLength * tangentDir;
                    
                    // Tangent vector line
                    ctx.strokeStyle = tangentialAccel >= 0 ? '#00b8ff' : '#0077cc';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(tangentEndX, tangentEndY);
                    ctx.stroke();
                    
                    // Tangent vector arrowhead
                    const arrowSize = Math.min(8, tangentLength / 3);
                    const angle = Math.atan2(vectors.tangent.y * tangentDir, vectors.tangent.x * tangentDir);
                    ctx.fillStyle = tangentialAccel >= 0 ? '#00b8ff' : '#0077cc';
                    ctx.beginPath();
                    ctx.moveTo(tangentEndX, tangentEndY);
                    ctx.lineTo(
                        tangentEndX - arrowSize * Math.cos(angle - Math.PI/6),
                        tangentEndY - arrowSize * Math.sin(angle - Math.PI/6)
                    );
                    ctx.lineTo(
                        tangentEndX - arrowSize * Math.cos(angle + Math.PI/6),
                        tangentEndY - arrowSize * Math.sin(angle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw normal vector (centripetal acceleration) - Red
                if (normalLength > 1) { // Only draw if acceleration is significant
                    // Direction: positive normal accel = toward center, negative = away
                    const normalDir = normalAccel >= 0 ? 1 : -1;
                    const normalEndX = this.x + vectors.normal.x * normalLength * normalDir;
                    const normalEndY = this.y + vectors.normal.y * normalLength * normalDir;
                    
                    // Normal vector line
                    ctx.strokeStyle = normalAccel >= 0 ? '#ff4757' : '#cc2e3f';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(normalEndX, normalEndY);
                    ctx.stroke();
                    
                    // Normal vector arrowhead
                    const arrowSize = Math.min(8, normalLength / 3);
                    const angle = Math.atan2(vectors.normal.y * normalDir, vectors.normal.x * normalDir);
                    ctx.fillStyle = normalAccel >= 0 ? '#ff4757' : '#cc2e3f';
                    ctx.beginPath();
                    ctx.moveTo(normalEndX, normalEndY);
                    ctx.lineTo(
                        normalEndX - arrowSize * Math.cos(angle - Math.PI/6),
                        normalEndY - arrowSize * Math.sin(angle - Math.PI/6)
                    );
                    ctx.lineTo(
                        normalEndX - arrowSize * Math.cos(angle + Math.PI/6),
                        normalEndY - arrowSize * Math.sin(angle + Math.PI/6)
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                // Particle shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 2, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Particle gradient
                const gradient = ctx.createRadialGradient(
                    this.x - 3, this.y - 3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, '#ffd700');
                gradient.addColorStop(1, '#ff8c00');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Particle highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x - 2, this.y - 2, this.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawScene() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#2c3e50');
            gradient.addColorStop(1, '#34495e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw start point
            ctx.fillStyle = '#ff4757';
            ctx.beginPath();
            ctx.arc(startPoint.x, startPoint.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('START', startPoint.x, startPoint.y - 25);

            // Draw end point
            ctx.fillStyle = '#2ed573';
            ctx.beginPath();
            ctx.arc(endPoint.x, endPoint.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('END', endPoint.x, endPoint.y + 35);

            // Draw path
            if (path.length > 1) {
                // Path shadow
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(path[0].x + 2, path[0].y + 2);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x + 2, path[i].y + 2);
                }
                ctx.stroke();

                // Main path
                ctx.strokeStyle = '#74b9ff';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();

                // Path highlights
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw particle
            if (particle) {
                particle.draw();
            }
        }

        function animate() {
            if (particle && isSimulating) {
                particle.update();
                drawScene();
                animationId = requestAnimationFrame(animate);
            }
        }

        // Event listeners
        canvas.addEventListener('mousedown', (e) => {
            const mousePos = getMousePos(e);
            if (isNearPoint(mousePos, startPoint) && !isSimulating) {
                isDrawing = true;
                path = [{ x: startPoint.x, y: startPoint.y }];
                status.textContent = 'Drawing path... end near the green circle!';
                simulateBtn.disabled = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) {
                const mousePos = getMousePos(e);
                path.push(mousePos);
                drawScene();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isDrawing) {
                const mousePos = getMousePos(e);
                isDrawing = false;
                
                if (isNearPoint(mousePos, endPoint, 30)) {
                    path.push({ x: endPoint.x, y: endPoint.y });
                    
                    // Smooth the path to reduce noise
                    path = reducePathPoints(path, 4); // Remove closely spaced points first
                    path = smoothPath(path, 5); // Then apply smoothing
                    
                    simulateBtn.disabled = false;
                    status.textContent = 'Great! Path smoothed and ready. Click "Start Simulation" to begin!';
                } else {
                    status.textContent = 'Path must end near the green circle. Try again!';
                    path = [];
                }
                drawScene();
            }
        });

        clearBtn.addEventListener('click', () => {
            path = [];
            particle = null;
            isSimulating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            simulateBtn.disabled = true;
            resetBtn.disabled = true;
            status.textContent = 'Ready to draw!';
            drawScene();
        });

        simulateBtn.addEventListener('click', () => {
            if (path.length > 1) {
                particle = new Particle(startPoint.x, startPoint.y);
                isSimulating = true;
                simulateBtn.disabled = true;
                resetBtn.disabled = false;
                status.textContent = 'Simulation running! Watch the particle roll down your track!';
                animate();
            }
        });

        resetBtn.addEventListener('click', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            particle = new Particle(startPoint.x, startPoint.y);
            isSimulating = false;
            simulateBtn.disabled = false;
            status.textContent = 'Particle reset. Click "Start Simulation" to run again!';
            drawScene();
        });

        // Initial draw
        drawScene();
    </script>
</body>
</html>
